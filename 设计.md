
## 游戏设计
- 消息管理
- 玩家管理
- 桌子管理
- 玩家数据管理
- 逻辑管理
- 监控

##  UML

Player
PlayerMgr
Bullet
BulletMgr
BasePart
PlayerBaseData

## 桌子的管理

## 玩家的管理

## 消息的管理
消息根据来源分为两类，来自玩家的消息(tcp)，来自其它服的消息(http)
### 处理来自其它服的消息处理
核心类 HttpMsg

这个类核心功能是启动一个http服务器，接收来自其它服(world)的http通知,目前它处理的通知只有一个，刷新玩家金币
```
HttpMsg::onFreshMoney{
    HallProto::FreshMoney recv;   // 参数 playerid
    
    // 从db获取玩家最新db金币数量
    int64 amount = QPHallMsg_c::refreshUserMoney(gameId, recv.playerid(), extCoin);
	if (amount < 0) {
		return HallProto::HMEC_FreshUserMoney;
	}

    // 计算 db 金币数量与进程中缓存的玩家初始金币数量 增量
	auto detal = player->refreshUserMoney(amount, extCoin);
	if (detal <= 0) {
		return HallProto::HMEC_FreshUserMoney;
	}

    // 同步增量通知给桌子
	player->syncMoneyToClient(SMTPurchase, detal, true);

    // 重新加载vip信息，并同步玩家信息到桌子
	player->loadVipInfo();
	player->userInfoNotify();

	return HallProto::HMEC_Sucess;
}
```

### 处理来自客户端的消息
```
核心类 Server4Frontend 主要功能注册网络事件，派发网络事件，监听Session close，Kick Session。
核心类 MessageHandler  主要功能是注册网络消息事件及消息的处理
射击消息事件处理类 ShootHandler、RocketShootHandler
捕获鱼消息网络事件类 HitHandler、RocketHitHandler、FreeGunHitHandler
```


--------
# 配置模块


### 游戏配置功能实现
**lua模块的初始化**

是在ServerBase::init函数中进行的,流程如下
- 1.遍历执行注册c++函数 registerLua
- 2.加载 main.lua 文件
- 3.遍历执行加载lua文件 loadLua

server lua初始化实现
```cpp
bool ServerBase::init(const std::string& strLuaPath)
{
	bool result = false;
	if (!strLuaPath.empty()) {
		//先保证将C++函数注册完,再加载lua
		lua_State* pLuaState = LuaGlobal::getInstance().getLuaState();
		IF_NOT_RETURN_VALUE(pLuaState, false);
		ServiceMgr::getInstance().registerLua(pLuaState);
		
		std::string luaPath	= strLuaPath + "main.lua";
		LuaGlobal::getInstance().doFile(luaPath.c_str());
		result = ServiceMgr::getInstance().loadLua(pLuaState);
	}
	else {
		LOGERROR("strLuaPath is empty!!!");
	}
	
	m_bRunning = true;
	m_scheduler.invoke(0, MIN_TIMER_INTVL, [this](VK::any usr_data) {
		ServiceMgr::getInstance().polling();
	});

	return result;
}
```


一般 lua 文件的注册与加载示例
```cpp
bool PropConfig::init()
{
	m_props.clear();
	m_propCtrl.clear();
	m_propParam.clear();
	m_medalZones.clear();
	return true;
}

void PropConfig::registerLua(lua_State* pLuaState)
{
	luabridge::getGlobalNamespace(pLuaState)
		.beginClass<PropConfig>("PropConfig")
		.addFunction("setProp", &PropConfig::setProp)
		.addFunction("setPropCtrl", &PropConfig::setPropCtrl)
		.addFunction("setPropParam", &PropConfig::setPropParam)
		.addFunction("setMedalZone", &PropConfig::setMedalZone)
		.endClass();
}

bool PropConfig::loadLua(lua_State* pLuaState)
{
	IF_NOT_RETURN_FALSE(pLuaState);

	init();
	if (!luabridge::call<bool>(pLuaState, "f_reload_prop_config", this)){
		const char *msg = lua_tostring(pLuaState, -1);
		LOGERROR(".... f_reload_prop_config Failure ...%s", msg);
		return false;
	}

	return true;
}
```
注:在lua中创建c++对象必须用addConstructor为该类注册构造函数


**lua文件的热加载**

在 GameConfig::loadLua 中设置了热加载时间间隔
```cpp
	ServiceMgr::getInstance().SetReloadLuaSec(m_nLoadFileTime);
```

在 ServiceMgr::polling 中进行了热加载触发,热加载时间间隔配置项是在 Config.lua 文件中 ["Game"]["LoadFileTime"] ,它本身也是可热更的

```cpp
bool ServiceMgr::reloadLua()
{
	auto ticks = BASE::GetTickCount();
	int32 d = m_nCheckLuaTicks + m_nReloadLuaSec*1000 - ticks;
	if (d > 0){
		return false;
	}

	m_nCheckLuaTicks = ticks;
	auto pLuaState = LuaGlobal::getInstance().getLuaState();
	IF_NOT_RETURN_FALSE(pLuaState);
	if (!luabridge::call<bool>(pLuaState, "f_reload")) {
		const char *msg = lua_tostring(pLuaState, -1);
		LOGERROR(".... f_reload Failure ...%s", msg);
		return false;
	}

	loadLua(pLuaState);

	LOGWARNING("reload lua .");
	return true;
}
```


**lua中访问c++**

首先需在c++中注册类，供lua访问,所有注册均放在 registerLua 函数里
--------


# 对接中台

## 配置中心
游戏服务器是c++实现的，所以目前不接入配置中心

## 日志中心
日志中心接入的本质是程序按格式(json)写入到日志文件，日志中心读取我们的日志文件上传到日志中心。

捕鱼游戏会被日志中心监控的日志文件名是 srbydld_big_money，程序调用打印接口是 LOG_BIGM_I 。

这个日志主要是收集玩家大额金币收益记录，收益金币必须大于 Config.lua 中 config["Game"]["BigMoneyMin"] 配置值时才会打印到日志文件。这里可做优化为每个场独立配置。

## 监控中心
配置 qp_en.json 新增监控统计上报地址
```
    "StatisticsUrl":"http://172.13.0.120:8030",
```

程序实现主要是 StatisticsCenter 单例类，提供了 addRecord 写入记录接口,程序主要写入了打怪日志和系统日志
```
	StatisticsCenter::getInstance().addRecord("monster", data)
    StatisticsCenter::getInstance().addRecord("system", data);
```
其中系统统计 上报时间间隔是在 Config.lua 中 config["Game"]["FishCacheTimeSec"] 配置值

内网中台 http://172.13.12.42:3000/   test  test   徐子涵

上报日志历史查询
```
http://172.13.0.120:8030/metrics
```

web监控添加游戏配置
```
游戏id 10087
游戏名 亲朋捕鱼纯净版
场
 1 初级场
 2 中级场
 3 高级场
 4 专家场
```


**监控统计**

**打怪统计**
```
// 统计消耗
void Player::fishRecord(int fishType, int validHit, int taxHit, int given, double cost)
{
	m_logCache.fishRecord(fishType, validHit, given, cost);
	LogFish::getInstance().fishRecord(fishType, validHit, taxHit, given, cost);
}
// 统计收益
void Player::fishRecord(int fishType, int earn)
{
	m_logCache.fishRecord(fishType, earn);
	LogFish::getInstance().fishRecord(fishType, earn);
}


->fishRecord
```



--------

# 数据库

## DB配置
- 游戏ID  10087 场ID 10542 , 
- 新框架内网库名：game_qp_H5srbydld
- 防刷池配置 SY_GameCenter.GameInfo.BaseGoldPool (由刘振宇通过web后台配置)
--------


## 方案